The retriever.py program is run on the raspberry pi. It interfaces with the database, and conveys information to the Arduino. Additionally, the program streams the USB cameras to the internet. 

The program receives snapshots of the information stored in the database through the reference.get() line of the firebase_admin library. In order to make sure that commands are not repeated, the program stores the states of the database. By comparing the stored values to new snapshots, the program detects if a change has occurred. If a change occurred, the program sends a byte array through the serial port to the Arduino. The array contains 3 bytes. The first being the start of text ASCII code (0x02 in hex) followed by the data (w,a,s, or d for the direction and q for shoot), followed by the end of text ASCII code (0x03 in hex).

The JSON file stores the structure of the database and is required in order for the program to navigate through the database and retrive the data from the refrences. It will have a name, unique to its firebase database. The name of the json file has been changed in this github for security reasons.

The streaming is slightly unrefined, in that it streams to Youtube. Youtube is not the most optimal streaming service since it has very high latency. Other services are significantly faster, the fastest being hosting an nginx streaming server and receiving the stream without a mediary service. 

In order for the program to send a stream, the webcam stream must be encoded into RTMP (Real-Time Messaging Protocol). The raspberry pi uses the ffmpeg program to encode the stream and send it to the url. This is done by using the OS.system() lines to kill processes which are running ffmpeg already (prevents issues with the webcams being busy when streaming is attempted), followed by subprocess.Popen([“ffmpeg -f v4l2…..”], shell=True) to run a terminal command that begins the encoding and streaming. It is vital to use a subprocess here since it allows the stream to run in parallel instead of stopping the rest of the program.

Through the same process used to read the movement data, the program recives an integer value from the database which coresponds to a certain USB camera. If the progam finds that the camera number in the database is different from the one currently streaming, it will kill the stream processes and begin encoding and streaming the other usb camera. This allows for the raspberry pi to control as many cameras as connected (but not all at once). 

The main downside of this setup is the lower processing speed of the raspberry pi. Encoding the camera to RTMP takes a lot of processing power. This is why the program is set up to only ever encode one camera at a time. When streaming a HD camera at a high bitrate, the raspberry pi can only provide 3-4 frames per second. This could be fixed if a raspberry pi camera is used instead of the USB cameras. 
